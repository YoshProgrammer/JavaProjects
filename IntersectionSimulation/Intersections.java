import jsjf.*;import java.lang.System;import java.util.*;import java.text.DecimalFormat;/** * Intersections demonstrates the use of a queue for simulating an intersection, and cars crossing within the * intersection. * * TESTING: * With Verbose mode on, and flipping the toggle manually in the calculateOptimalLightChange I was able to view * the outputs of each run of the program. The calculateOptimalLightChange doubles as a tester function as it * runs through the program 30 times to determine the output. With logging turned on I was able to review the outputs * and make sure it was working as intended. */public class Intersections {    private static int LIGHT_LENGTH;    private static double CAR_GENERATION_CHANCE;    private final static int SIMULATION_LIMIT = 1000;    private static String currentQueue;    private static int southCount, westCount, northCount, eastCount;    private static int southWaitTime, westWaitTime, eastWaitTime, northWaitTime;    private static int timer, carArrival, count, optimalLightChange;    private static Car car;    private static LinkedQueue<Car> carQueueNorth = new LinkedQueue<Car>();    private static LinkedQueue<Car> carQueueSouth = new LinkedQueue<Car>();    private static LinkedQueue<Car> carQueueEast = new LinkedQueue<Car>();    private static LinkedQueue<Car> carQueueWest = new LinkedQueue<Car>();    private static Scanner scan = new Scanner(System.in);    private static boolean verboseMode = true;    public static void main(String[] args) {        System.out.print("Do you want to enable logging? (true/false) ");        verboseMode = scan.nextBoolean();        System.out.print("Enter a new car creation chance: (0.00 - 1.00) ");        CAR_GENERATION_CHANCE = scan.nextDouble();        System.out.print("Enter a new duration for traffic lights (seconds): ");        LIGHT_LENGTH = scan.nextInt();        for (timer = 0; timer < SIMULATION_LIMIT; timer++) {            if (timer % LIGHT_LENGTH == 0) {                switchLights();            }            if (createCarCheck()) {                createCarInAppropriateQueues(timer);            }            removeCarsFromQueue();        }        generatePrintOutOfResults();        calculateOptimalLightChange();    }    /**     * Function used to determine if a car is generated or not.     */    private static boolean createCarCheck() {        return Math.random() <= CAR_GENERATION_CHANCE;    }    /**     * Helper function to log statements to the console, if enabled.     *     * @param statement     */    private static void log(String statement) {        if (verboseMode) {            System.out.println(statement);        }    }    /**     * Removes cars from the correct queue when the light is green.     */    private static void removeCarsFromQueue() {        log("Light is green for: " + currentQueue);        for (int count = 0; count <= LIGHT_LENGTH; count++) {            log("Count is: " + count);            switch (currentQueue) {                case "north":                    if (!carQueueNorth.isEmpty()) {                        log("Remove car from North queue.");                        car = carQueueNorth.dequeue();                        carArrival = car.getArrivalTime();                        car.setDepartureTime(timer);                        northWaitTime += car.totalTime();                    }                    break;                case "south":                    if (!carQueueSouth.isEmpty()) {                        log("Remove car from South queue.");                        car = carQueueSouth.dequeue();                        carArrival = car.getArrivalTime();                        car.setDepartureTime(timer);                        southWaitTime += car.totalTime();                    }                    break;                case "east":                    if (!carQueueEast.isEmpty()) {                        log("Remove car from East queue.");                        car = carQueueEast.dequeue();                        carArrival = car.getArrivalTime();                        car.setDepartureTime(timer);                        eastWaitTime += car.totalTime();                    }                    break;                case "west":                    if (!carQueueWest.isEmpty()) {                        log("Remove car from West queue.");                        car = carQueueWest.dequeue();                        carArrival = car.getArrivalTime();                        car.setDepartureTime(timer);                        westWaitTime += car.totalTime();                    }                    break;            }        }    }    /**     * Creates a car in the correct queues (all queues except the green one)     *     * @param count     */    private static void createCarInAppropriateQueues(int count) {        log("Adding Cars to all queues except: " + currentQueue);        switch (currentQueue) {            case "north":                carQueueSouth.enqueue(new Car(count));                southCount++;                carQueueEast.enqueue(new Car(count));                eastCount++;                carQueueWest.enqueue(new Car(count));                westCount++;                break;            case "south":                carQueueNorth.enqueue(new Car(count));                northCount++;                carQueueEast.enqueue(new Car(count));                eastCount++;                carQueueWest.enqueue(new Car(count));                westCount++;                break;            case "east":                carQueueSouth.enqueue(new Car(count));                southCount++;                carQueueNorth.enqueue(new Car(count));                northCount++;                carQueueWest.enqueue(new Car(count));                westCount++;                break;            case "west":                carQueueSouth.enqueue(new Car(count));                southCount++;                carQueueEast.enqueue(new Car(count));                eastCount++;                carQueueNorth.enqueue(new Car(count));                northCount++;                break;        }    }    /**     * Switches the light to green for the correct queue (intersection)     */    private static void switchLights() {        if (count <= 2) {            count += 1;        } else {            count = 0;        }        switch (count) {            case 0:                currentQueue = "north";                break;            case 1:                currentQueue = "south";                break;            case 2:                currentQueue = "west";                break;            case 3:                currentQueue = "east";                break;        }        log("Changing light to Green for:  " + currentQueue);    }    /**     * Generates a print out of the results of each intersection     */    private static void generatePrintOutOfResults() {        log("Generating results");        int averageNorthWaitTime = (int) (northWaitTime / northCount);        int averageSouthWaitTime = (int) (southWaitTime / southCount);        int averageWestWaitTime = (int) (westWaitTime / westCount);        int averageEastWaitTime = (int) (eastWaitTime / eastCount);        System.out.println();        System.out.format("%16s%16s%16s%16s%16s", " ", "North", "South", "East", "West");        System.out.println();        System.out.format("%16s%16s%16s%16s%16s", "Cars Across", (northCount - carQueueNorth.size()),                (southCount - carQueueSouth.size()), (eastCount - carQueueEast.size()), (westCount - carQueueWest.size()));        System.out.println();        System.out.format("%16s%16d%16d%16d%16d", "Cars Stranded",                carQueueNorth.size(), carQueueSouth.size(), carQueueEast.size(), carQueueWest.size());        System.out.println();        System.out.format("%16s%16d%16d%16d%16d", "Total Delay", northWaitTime,                southWaitTime, eastWaitTime, westWaitTime);        System.out.println();        System.out.format("%16s%16s%16s%16s%16s", "Delay Average", Integer.toString(averageNorthWaitTime),                Integer.toString(averageSouthWaitTime), Integer.toString(averageEastWaitTime), Integer.toString(averageEastWaitTime));        System.out.println();    }    /**     * Runs from 1-30 seconds, calculating the optimal light change.     * The optimal light change is determined by the least number of stranded cars.     * This is calculated per each user's guidelines.     */    private static void calculateOptimalLightChange() {        log("Calculating optimal light change");        //This function creates "spammy" logs. Only turn on when debugging.        verboseMode = false;        int totalStrandedCars = 0;        int leastStrandedCars = 0;        for (int i = 1; i <= 30; i++) {            LIGHT_LENGTH = i;            totalStrandedCars = 0;            for (timer = 0; timer < SIMULATION_LIMIT; timer++) {                if (timer % LIGHT_LENGTH == 0) {                    switchLights();                }                if (createCarCheck()) {                    createCarInAppropriateQueues(timer);                }                removeCarsFromQueue();            }            int totalCount = (carQueueEast.size() + carQueueNorth.size() + carQueueSouth.size() + carQueueWest.size());            totalStrandedCars += totalCount;            if (LIGHT_LENGTH == 1) {                leastStrandedCars = totalStrandedCars;                optimalLightChange = LIGHT_LENGTH;            }            if (totalStrandedCars < leastStrandedCars) {                leastStrandedCars = totalStrandedCars;                optimalLightChange = LIGHT_LENGTH;            }        }        System.out.println();        System.out.println("For a car generation percentage of " + (CAR_GENERATION_CHANCE * 100) + "% the optimal light change" +                "time is: " + optimalLightChange + " seconds. It resulted in the least number of stranded cars: " + leastStrandedCars);    }}